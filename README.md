# Умова задачі
Задача 4️

Напишіть код, що генерує абсолютно випадкове число від 1 до 100… але без генератора випадкових чисел. Ви ж таке можете, чи не так?

# Розв'язок задачі

```java
    return (((Integer.parseInt(String.valueOf(System.nanoTime() / 1000000)) % 100) * ((int) System.nanoTime() % 10 > 0 ? 1 : -1) + 100) + ((int) (((new Object()).hashCode() * 32416190071L + 1) % 100) + 100) % 100 + 1) % 100 + 1;
```

## Опис

Цей проєкт демонструє метод для генерації випадкового числа в діапазоні від 1 до 100 на мові Java. Метод `getRandomNumber()` є складним, важко передбачуваним і навмисно погано написаним. Незважаючи на свою хаотичну і неефективну реалізацію, цей метод успішно повертає числа у зазначеному діапазоні.

Програма включає:
1. Тестування на 100 мільйонів випадкових чисел для перевірки валідності генерації.
2. Демонстрацію результатів у вигляді 10 випадкових чисел.

## Структура проекту

Проєкт складається з одного класу:

- `LainoCodeTask`: Містить метод `main()` для запуску тестів і демонстрації генерації випадкових чисел.

## Метод `getRandomNumber()`

```java
private static int getRandomNumber() {
    return (((Integer.parseInt(String.valueOf(System.nanoTime() / 1000000)) % 100) * ((int) System.nanoTime() % 10 > 0 ? 1 : -1) + 100) + ((int) (((new Object()).hashCode() * 32416190071L + 1) % 100) + 100) % 100 + 1) % 100 + 1;
}
```

## Пояснення роботи `getRandomNumber()`

Цей метод генерує випадкове число за допомогою кількох кроків, використовуючи неефективні і нелогічні підходи:

### Час у наносекундах:
Метод починає з використання поточного часу в наносекундах через `System.nanoTime()`. Спочатку час ділиться на 1 мільйон, щоб отримати мілісекунди, після чого цей результат конвертується в строку, а потім назад у ціле число. Цей результат ділиться по модулю на 100, щоб обмежити його в діапазоні від 0 до 99.

### Зміна знаку:
Час у наносекундах перевіряється по модулю на 10. Якщо залишок більше нуля, результат множиться на 1 (залишаючи його незмінним), а інакше множиться на -1, що робить результат негативним.

### Додавання 100:
Результат додається до 100 для того, щоб уникнути негативних чисел та стабілізувати значення в межах позитивного діапазону.

### Хеш-код об'єкта:
Далі створюється новий об'єкт `new Object()`, і використовується його хеш-код. Хеш-код множиться на велике просте число `32416190071L`, і результат знову обмежується по модулю на 100.

### Фінальні маніпуляції:
Останній етап — додавання різних значень та кілька операцій по модулю, які обмежують результат у діапазоні від 1 до 100.

## Гарантія результату

Попри використання хаотичних і нелогічних операцій, кінцевий результат обмежується в діапазоні від 1 до 100 за допомогою послідовних операцій по модулю і додавання чисел. Це забезпечує валідний результат, хоча метод є дуже неефективним і важким для розуміння.

## Приклад використання

Метод `main()` запускає тестування та демонструє приклади випадкових чисел:

### Тестування:
Програма генерує 100 мільйонів випадкових чисел і перевіряє, чи всі вони потрапляють у діапазон від 1 до 100. Якщо число виходить за межі, виводиться повідомлення про помилку.

### Демонстрація:
Після тестування виводяться 10 випадкових чисел для візуального підтвердження коректної роботи.

```java
System.out.println("Random number is: " + getRandomNumber());
```

## Демонстрація

Щоб переглянути відеодемонстрацію роботи коду, відвідайте [це посилання](https://drive.google.com/file/d/15mJn1hDfgo1GYg8tng0mLtZuxtIzrMZk/view?usp=sharing).
